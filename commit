#!/bin/bash

# ------------------------------------------------------------------------------
# settings                                                              settings
# ------------------------------------------------------------------------------
set -o errtrace  # any trap on ERR is inherited by shell functions,
                 #   command substitutions, and commands executed in a subshell
                 #   environment
set -o nounset   # treat unset variables and parameters other than the special
                 #   parameters "@" and "*" as an error when performing
                 #   parameter expansion
set -o pipefail  # the return value of a pipeline is the value of the last
                 #   (rightmost) command to exit with a non-zero status, or
                 #   zero if all commands in the pipeline exit successfully

# set language
export LANG="en_US.UTF-8"

# use dot as decimal separator
export LC_NUMERIC="en_US.UTF-8"

# terminal colors
readonly    NONE=$(tput sgr0)
readonly     RED=$(tput setaf 1)
readonly   GREEN=$(tput setaf 2)
readonly  YELLOW=$(tput setaf 3)
readonly    BLUE=$(tput setaf 4)
readonly MAGENTA=$(tput setaf 5)
readonly    CYAN=$(tput setaf 6)
readonly   WHITE=$(tput setaf 7)

# ------------------------------------------------------------------------------
# functions                                                            functions
# ------------------------------------------------------------------------------

# -------
# failmsg
# -------
#
# This function prints a red colored message via stderr.
#
function failmsg()
{
  # push to stderr
  echo -e "${RED}[FAIL]${NONE} $1" 1>&2
}

# -------
# warnmsg
# -------
#
# This function prints a yellow colored message via stderr.
#
function warnmsg()
{
  # push to stderr
  echo -e "${YELLOW}[WARN]${NONE} $1" 1>&2
}

# -------
# infomsg
# -------
#
# This function prints a blue colored message via stderr.
#
function infomsg()
{
  # push to stderr
  echo -e "${BLUE}[INFO]${NONE} $1" 1>&2
}

# -------
# donemsg
# -------
#
# This function prints a green colored message via stderr.
#
function donemsg()
{
  # push to stderr
  echo -e "${GREEN}[DONE]${NONE} $1" 1>&2
}

# ----------
# utf82ascii
# ----------
#
# ... | utf82ascii | ...
#
function utf82ascii()
{
  sed --regexp-extended \
      --expression="
        # escape all colons
        s/:/:c/g

        # escape all native question marks (iconv may introduce much more)
        s/\\?/:q/g

        # collection of characters that aren't translated (suitable) by iconv
        s/¦/|/g
        s/¡/!/g
        s/¿/:q/g
        s/„/\"/g
        s/«/\"/g
        s/»/\"/g
        s/÷/\//g
        s/±/+-/g
        s/¹/^1/g
        s/²/^2/g
        s/³/^3/g
        s/Ä/Ae/g
        s/ä/ae/g
        s/Ö/Oe/g
        s/ö/oe/g
        s/Ü/Ue/g
        s/ü/ue/g
        s/Ø/Oe/g
        s/ø/oe/g
        s/Ð/Dh/g
        s/ð/dh/g
        s/Þ/Th/g
        s/þ/th/g
      "                                       \
  | iconv --from-code "UTF-8"                 \
          --to-code "ASCII//TRANSLIT//IGNORE" \
  | sed --regexp-extended                     \
        --expression="
          # remove all question marks introduced by iconv
          s/\\?//g

          # restore all escaped question marks
          s/:q/?/g

          # restore all escaped colons
          s/:c/:/g
        "
}

# --------
# simplify
# --------
#
# ... | simplify | ...
#
function simplify()
{
  sed --regexp-extended \
      --expression="

        # replace everything but letters and numbers
        s/[^[:alnum:]]+/_/g

        # lower case
        s/.+/\L&/

        # trim both ends
        s/^_//
        s/_$//

      "
}

# ----------------------
# find_next_track_number
# ----------------------
#
# $1  directory
#
function find_next_track_number()
{
  {
    # assert at least one file to be piped
    echo "000_dummy.mp3"

    # find all mp3 files
    find "$1"                                         \
         -maxdepth "1"                                \
         -type "f"                                    \
         -regextype "posix-extended"                  \
         -regex ".+/[[:digit:]]{3}_[^/]+\.[Mm][Pp]3$" \
         -printf "%f\n"

  }                                                   \
  | sort                                              \
  | tail -n "1"                                       \
  | sed -nre "s/^0*([[:digit:]]+).+/\1 + 1/p"         \
  | bc
}

# ------------------
# create_cover_image
# ------------------
#
# $1  background image
# $2  foreground images (date file)
# $3  jpeg quality
# $4  output file
#
function create_cover_image()
{
  # create temporary file
  local TEMPFILE=$(mktemp --suffix=".png")

  # composite png images
  composite -gravity    "SouthWest"        \
            "$2" "$1"                      \
            -colorspace "sRGB"             \
            -type       "TrueColorMatte"   \
            -define     "png:bit-depth=8"  \
            -define     "png:color-type=6" \
            -define     "png:format=png32" \
            "PNG32:$TEMPFILE"

  # convert to jpeg
  convert "$TEMPFILE" -quality "$3" "$4"

  # remove temporary file
  rm -f "$TEMPFILE" 2>"/dev/null"
}

# ------------------------------------------------------------------------------
# commands                                                              commands
# ------------------------------------------------------------------------------

# make commit work only for these files
CFGFILE="raw/wdr_zeitzeichen_2018_08_16_07_45_45_utc_rudolf_schulten_kernphysiker_geburtstag_16_08_1923.cfg"
MP3FILE="raw/wdr_zeitzeichen_2018_08_16_07_45_45_utc_rudolf_schulten_kernphysiker_geburtstag_16_08_1923.mp3"

# check cfg file
if [ ! -f "$CFGFILE" ] ; then

  # notify user
  failmsg "unable to locate file: \"$CFGFILE\""

  # signalize trouble
  exit 1

fi

# check mp3 file
if [ ! -f "$MP3FILE" ] ; then

  # notify user
  failmsg "unable to locate file: \"$MP3FILE\""

  # signalize trouble
  exit 1

fi

# get directory of the cfg file (assert trailing slash)
ABSDIR=$(dirname "$(readlink -e "$CFGFILE")" | sed -re "s|.+|&/| ; s|//$|/|")

# change working directory due to relative paths in the cfg file
cd "$ABSDIR"

# update paths
CFGFILE=$(basename "$CFGFILE")
MP3FILE=$(basename "$MP3FILE")

# show progress
infomsg "operating file: $CFGFILE"

# this array holds all data from the cfg file
declare -A CFGDATA

# read data from cfg file
 CFGDATA["BACKGROUND"]=$(sed -nre "s/^BACKGROUND=(.+)/\1/p"  "$CFGFILE")
 CFGDATA["FOREGROUND"]=$(sed -nre "s/^FOREGROUND=(.+)/\1/p"  "$CFGFILE")
CFGDATA["COMPRESSION"]=$(sed -nre "s/^COMPRESSION=(.+)/\1/p" "$CFGFILE")
     CFGDATA["TOPDIR"]=$(sed -nre "s/^TOPDIR=(.+)/\1/p"      "$CFGFILE")
      CFGDATA["GENRE"]=$(sed -nre "s/^GENRE=(.+)/\1/p"       "$CFGFILE" | utf82ascii)
     CFGDATA["ARTIST"]=$(sed -nre "s/^ARTIST=(.+)/\1/p"      "$CFGFILE" | utf82ascii)
      CFGDATA["ALBUM"]=$(sed -nre "s/^ALBUM=(.+)/\1/p"       "$CFGFILE" | utf82ascii)
       CFGDATA["YEAR"]=$(sed -nre "s/^YEAR=(.+)/\1/p"        "$CFGFILE")
      CFGDATA["TITLE"]=$(sed -nre "s/^TITLE=(.+)/\1/p"       "$CFGFILE" | utf82ascii)
    CFGDATA["COMMENT"]=$(sed -nre "s/^COMMENT=(.+)/\1/p"     "$CFGFILE" | utf82ascii)
     CFGDATA["AUTHOR"]=$(sed -nre "s/^AUTHOR=(.+)/\1/p"      "$CFGFILE" | utf82ascii)
    CFGDATA["AIRTIME"]=$(sed -nre "s/^AIRTIME=(.+)/\1/p"     "$CFGFILE")
    CFGDATA["SORTKEY"]=$(sed -nre "s/^SORTKEY=(.+)/\1/p"     "$CFGFILE")
  CFGDATA["WEBSOURCE"]=$(sed -nre "s/^WEBSOURCE=(.+)/\1/p"   "$CFGFILE")

# check if some data is missing
for KEY in "BACKGROUND"  \
           "FOREGROUND"  \
           "COMPRESSION" \
           "TOPDIR"      \
           "GENRE"       \
           "ARTIST"      \
           "ALBUM"       \
           "YEAR"        \
           "TITLE"       \
           "COMMENT"     \
           "AUTHOR"      \
           "AIRTIME"     \
           "SORTKEY"     \
           "WEBSOURCE"
do

  # check data
  if [ -z "${CFGDATA[$KEY]}" ] ; then

    # notify user
    failmsg "missing data: $KEY"

    # signalize trouble
    exit 1

  fi

done

# assert trailing slash
CFGDATA["TOPDIR"]=$(sed -re "s|.+|&/| ; s|//$|/|" <<< "${CFGDATA[TOPDIR]}")

# check if target directory is present
if [ ! -d "${CFGDATA[TOPDIR]}" ] ; then

  # try to create target directory
  mkdir -p "${CFGDATA[TOPDIR]}" 2>"/dev/null"

  # target directory is still missing
  if [ ! -d "${CFGDATA[TOPDIR]}" ] ; then

    # notify user
    failmsg "unable to create target directory: \"${CFGDATA[TOPDIR]}\""

    # signalize trouble
    exit 1

  fi

fi

# check if background image is missing
if [ ! -f "${CFGDATA[BACKGROUND]}" ] ; then

  # notify user
  failmsg "unable to locate file: \"${CFGDATA[BACKGROUND]}\""

  # signalize trouble
  exit 1

fi

# check if foreground image is missing
if [ ! -f "${CFGDATA[FOREGROUND]}" ] ; then

  # notify user
  failmsg "unable to locate file: \"${CFGDATA[FOREGROUND]}\""

  # signalize trouble
  exit 1

fi

# set final output directory
TARGETDIR="${CFGDATA[TOPDIR]}$(simplify <<< "${CFGDATA[ALBUM]}")/"

# check if final output directory is missing
if [ ! -d "$TARGETDIR" ] ; then

  # try to create final output directory 
  mkdir -p "$TARGETDIR" 2>"/dev/null"

  # final output directory is still missing
  if [ ! -d "$TARGETDIR" ] ; then

    # notify user
    failmsg "unable to create directory: \"$TARGETDIR\""

    # signalize trouble
    exit 1

  fi

fi

# get largest unused track number
TRACKNUMBER=$(find_next_track_number "$TARGETDIR")

# check tracknumber
if [ -z "$TRACKNUMBER" ] ; then

  # notify user
  failmsg "unable to find largest tracknumber in \"$TARGETDIR\""

  # signalize trouble
  exit 1

fi

# set final filename
TARGETFILE=$(printf "%03d %s" "$TRACKNUMBER" "${CFGDATA[TITLE]}" | simplify | sed -re "s/.+/&.mp3/")

# just as a matter of principle
if [ -f "${TARGETDIR}${TARGETFILE}" ] ; then

  # notify user
  failmsg "file already exists: ${TARGETDIR}${TARGETFILE}"

  # signalize trouble
  exit 1

fi

# rename cfg file
DONEFILE=$(sed -nre "s/\.cfg$/.done/p" <<< "$CFGFILE")

# check filename
if [ -z "$DONEFILE" ] ; then

  # notify user
  failmsg "unable to rename cfg file"

  # signalize trouble
  exit 1

fi

# remove (reset) all current tags
eyeD3 --no-tagging-time-frame \
      --remove-comments       \
      --remove-lyrics         \
      --remove-images         \
      --remove-all            \
      --v2                    \
      --to-v2.3               \
      --title="none"          \
      --artist="none"         \
      --album="none"          \
      --year="none"           \
      --track="1"             \
      "$MP3FILE"              &>"/dev/null"

# check exit status
if (( $? != 0 )) ; then

  # notify user
  failmsg "unable to edit ID3 tags: \"$MP3FILE\""

  # signalize trouble
  exit 1

fi

# create temporary file
FRONTCOVER=$(mktemp --suffix=".jpg")

# create cover image
create_cover_image "${CFGDATA[BACKGROUND]}"  \
                   "${CFGDATA[FOREGROUND]}"  \
                   "${CFGDATA[COMPRESSION]}" \
                   "$FRONTCOVER"

# check file size
if [ ! -s "$FRONTCOVER" ] ; then

  # remove temporary file
  rm -f "$FRONTCOVER" 2>"/dev/null"

  # notify user
  failmsg "unable to create cover image"

  # signalize trouble
  exit 1

fi

# update tags
eyeD3 --no-tagging-time-frame                                                    \
      --v2                                                                       \
      --to-v2.3                                                                  \
      --genre="${CFGDATA[GENRE]}"                                                \
      --artist="${CFGDATA[ARTIST]}"                                              \
      --album="${CFGDATA[ALBUM]}"                                                \
      --title="${CFGDATA[TITLE]}"                                                \
      --year="${CFGDATA[YEAR]}"                                                  \
      --track="$TRACKNUMBER"                                                     \
      --comment="eng::${CFGDATA[COMMENT]}"                                       \
      --add-image="$FRONTCOVER:FRONT_COVER:$(basename "${CFGDATA[BACKGROUND]}")" \
      --set-user-text-frame="AUTHOR:${CFGDATA[AUTHOR]}"                          \
      --set-user-text-frame="AIRTIME:${CFGDATA[AIRTIME]}"                        \
      --set-user-text-frame="SORTKEY:${CFGDATA[SORTKEY]}"                        \
      --set-user-text-frame="WEBSOURCE:${CFGDATA[WEBSOURCE]}"                    \
      "$MP3FILE"                                                                 &>"/dev/null"

# remove temporary file
rm -f "$FRONTCOVER" 2>"/dev/null"

# move mp3 file to final position
mv -f "$MP3FILE" "${TARGETDIR}${TARGETFILE}"

# rename cfg file
mv -f "$CFGFILE" "$DONEFILE"

# show progress
donemsg "file created: ${TARGETDIR}${TARGETFILE}"

# signalize success
exit 0
