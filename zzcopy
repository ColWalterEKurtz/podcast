#!/bin/bash

# ------------------------------------------------------------------------------
# settings                                                              settings
# ------------------------------------------------------------------------------
set -o errexit   # exit immediately if a command exits with a non-zero status
set -o errtrace  # any trap on ERR is inherited by shell functions,
                 #   command substitutions, and commands executed in a subshell
                 #   environment
set -o nounset   # treat unset variables and parameters other than the special
                 #   parameters "@" and "*" as an error when performing
                 #   parameter expansion
set -o pipefail  # the return value of a pipeline is the value of the last
                 #   (rightmost) command to exit with a non-zero status, or
                 #   zero if all commands in the pipeline exit successfully

# set language
export LANG="en_US.UTF-8"

# use dot as decimal separator
export LC_NUMERIC="en_US.UTF-8"

# terminal colors
readonly    NONE=$(tput sgr0)
readonly     RED=$(tput setaf 1)
readonly   GREEN=$(tput setaf 2)
readonly  YELLOW=$(tput setaf 3)
readonly    BLUE=$(tput setaf 4)
readonly MAGENTA=$(tput setaf 5)
readonly    CYAN=$(tput setaf 6)
readonly   WHITE=$(tput setaf 7)

# ------------------------------------------------------------------------------
# functions                                                            functions
# ------------------------------------------------------------------------------

# -------
# failmsg
# -------
#
# This function prints a red colored message via stderr.
#
function failmsg()
{
  # push to stderr
  echo -e "${RED}[FAIL]${NONE} $1" 1>&2
}

# -------
# warnmsg
# -------
#
# This function prints a yellow colored message via stderr.
#
function warnmsg()
{
  # push to stderr
  echo -e "${YELLOW}[WARN]${NONE} $1" 1>&2
}

# -------
# infomsg
# -------
#
# This function prints a blue colored message via stderr.
#
function infomsg()
{
  # push to stderr
  echo -e "${BLUE}[INFO]${NONE} $1" 1>&2
}

# -------
# donemsg
# -------
#
# This function prints a green colored message via stderr.
#
function donemsg()
{
  # push to stderr
  echo -e "${GREEN}[DONE]${NONE} $1" 1>&2
}

# ------------------------------------------------------------------------------
# options                                                                options
# ------------------------------------------------------------------------------

# set default values
OPMODE="DEFAULT"

# set options to accept
readonly KNOWN_OPTIONS=":hv"

# check passed options
while getopts "$KNOWN_OPTIONS" OPTION "$@"
do

  case "$OPTION" in

    # show help
    "h") OPMODE="SHOW_HELP"
         ;;

    # show version
    "v") OPMODE="SHOW_VERSION"
         ;;

    "?") failmsg "unknown option: -$OPTARG"
         exit 1
         ;;

    ":") failmsg "missing argument: -$OPTARG <argument>"
         exit 1
         ;;

  esac

done

# get number of positional parameters
PPNUM=$(( $# - OPTIND + 1 ))

# drop all parsed options
shift $(( OPTIND - 1 ))

# ------------------------------------------------------------------------------
# commands                                                              commands
# ------------------------------------------------------------------------------

# check number of positional parameters
if (( PPNUM != 1 )) ; then

  # notify user
  failmsg "exactly one positional parameter needed: $(basename "$0") <target dir>"

  # signalize trouble
  exit 1

fi

# set directory names
SOURCEDIR="$HOME/podcast/audio/ZeitZeichen/"
TARGETDIR=$(sed -re "s|.+|&/| ; s|//$|/|" <<< "$1")

# check if target directory is missing
if [ ! -d "$TARGETDIR" ] ; then

  # try to create target directory
  mkdir --parents "$TARGETDIR" &>"/dev/null"

  # check if target directory is still missing
  if [ ! -d "$TARGETDIR" ] ; then

    # notify user
    failmsg "unable to create directory: \"$TARGETDIR\""

    # signalize trouble
    exit 1

  fi

fi

# check write permission
if [ ! -w "$TARGETDIR" ] ; then

  # notify user
  failmsg "no write permission: \"$TARGETDIR\""

  # signalize trouble
  exit 1

fi

# show progress
infomsg "removing fractional part from modification time..."

# remove fractional part from modification time
find "$SOURCEDIR"                 \
      -type      "f"              \
      -regextype "posix-extended" \
      -regex     ".+\.[Mm][Pp]3$" \
| LC_ALL=C sort                   \
| while read -r FILENAME
do

  # get fractional and fix modification time
  FRACTIME=$(stat --format="%y" "$FILENAME")
  INTSTIME=$(sed -nre "s/(:[[:digit:]]{2})\.[[:digit:]]+([[:space:]].+)/\1\2/p" <<< "$FRACTIME")

  # get current timestamp
  PRIOR=$(find "$FILENAME" -printf "%T+ %p\n")

  # remove fractional part from modification time
  touch -d "$INTSTIME" "$FILENAME"

  # get new timestamp
  AFTER=$(find "$FILENAME" -printf "%T+ %p\n")

  # show changes
  if [ "$PRIOR" != "$AFTER" ] ; then
     echo "$AFTER"
  fi

done

# create temporary files
TEMPS=$(mktemp --suffix=".$(basename "$0").source")
TEMPT=$(mktemp --suffix=".$(basename "$0").target")

# clean up on exit
trap 'rm -f "$TEMPS" "$TEMPT"' EXIT

# show progress
infomsg "creating list of source files..."

# list all source files
find "$SOURCEDIR"                 \
      -type      "f"              \
      -regextype "posix-extended" \
      -regex     ".+\.[Mm][Pp]3$" \
      -printf    "%T+ %P\n"       \
| LC_ALL=C sort                   \
> "$TEMPS"

# show progress
infomsg "creating list of target files..."

# list target files that are already present
find "$TARGETDIR"                 \
      -type      "f"              \
      -regextype "posix-extended" \
      -regex     ".+\.[Mm][Pp]3$" \
      -printf    "%T+ %P\n"       \
| LC_ALL=C sort                   \
> "$TEMPT"

# get number of source and target files
NSF=$(sed -re "/^[[:space:]]*$/d" "$TEMPS" | wc -l)
NTF=$(sed -re "/^[[:space:]]*$/d" "$TEMPT" | wc -l)

# get number of files to remove and copy
NRM=$(comm -13 "$TEMPS" "$TEMPT" | sed -re "/^[[:space:]]*$/d" | wc -l)
NCP=$(comm -23 "$TEMPS" "$TEMPT" | sed -re "/^[[:space:]]*$/d" | wc -l)

# show plan
printf "source files   : %d\n" "$NSF"
printf "target files   : %d\n" "$NTF"
printf "files to remove: %d\n" "$NRM"
printf "files to copy  : %d\n" "$NCP"

# check number of changes
if (( NRM + NCP > 50 )) ; then

  # notify user
  infomsg "more than 50 changes: waiting 10 seconds to start..."

  # wait before changing many files
  sleep 10

fi

# remove files that no longer exist
comm -13 "$TEMPS" "$TEMPT"                  \
| sed -nre "s/^[^[:space:]]+[[:space:]]//p" \
| LC_ALL=C sort                             \
| while read -r FILENAME
do

  # set name of file to remove
  DST="$TARGETDIR$FILENAME"

  # show progress
  infomsg "removing file:"
  find "$DST" -printf "%h\n%f\n%T+\n\n" \
  | sed -re "s/^(.{77})....+/\1.../"

  # remove given file
  rm -f "$DST"

done

# copy new and updated files
comm -23 "$TEMPS" "$TEMPT"                  \
| sed -nre "s/^[^[:space:]]+[[:space:]]//p" \
| LC_ALL=C sort                             \
| while read -r FILENAME
do

  SRC="$SOURCEDIR$FILENAME"
  DST="$TARGETDIR$FILENAME"
  DIR="$(dirname "$DST")"

  # check if directoty is missing
  if [ ! -d "$DIR" ] ; then

    # create directory if missing
    mkdir --parents "$DIR"

    # check if directoty is still missing
    if [ ! -d "$DIR" ] ; then

      # notify user
      failmsg "unable to create directory: \"$DIR\""

      # signalize trouble
      exit 1

    fi

  fi

  # copy mp3 file
  cp "$SRC" "$DST"

  # get source time without fractional part
  SRCTIME=$(stat --format="%y" "$SRC" | sed -nre "s/(:[[:digit:]]{2})\.[[:digit:]]+([[:space:]].+)/\1\2/p")

  # set same modification time
  touch -d "$SRCTIME" "$DST"

  # show progress
  infomsg "file created:"
  find "$DST" -printf "%h\n%f\n%T+\n" \
  | sed -re "s/^(.{77})....+/\1.../"
  echo

done

# signalize success
exit 0

