#!/bin/bash

# ------------------------------------------------------------------------------
# settings                                                              settings
# ------------------------------------------------------------------------------
set -o errexit   # exit immediately if a command exits with a non-zero status
set -o errtrace  # any trap on ERR is inherited by shell functions,
                 #   command substitutions, and commands executed in a subshell
                 #   environment
set -o nounset   # treat unset variables and parameters other than the special
                 #   parameters "@" and "*" as an error when performing
                 #   parameter expansion
set -o pipefail  # the return value of a pipeline is the value of the last
                 #   (rightmost) command to exit with a non-zero status, or
                 #   zero if all commands in the pipeline exit successfully

# set language
export LANG="en_US.UTF-8"

# use dot as decimal separator
export LC_NUMERIC="en_US.UTF-8"

# ------------------------------------------------------------------------------
# functions                                                            functions
# ------------------------------------------------------------------------------

# -------------
# get_next_line
# -------------
#
# $1  filename
#
function get_next_line()
{
  sed --quiet           \
      --regexp-extended \
      --expression="

        # skip empty lines
        /^[[:space:]]*$/ b

        # skip comments
        /^[[:space:]]*#/ b

        # print line and exit
        p ; q

      " "$1"
}

# --------------
# hide_next_line
# --------------
#
# $1  filename
#
function hide_next_line()
{
  sed --in-place        \
      --regexp-extended \
      --expression="

          # create sharp character on hold buffer
          1 { h; s/.*/# / ; x }

          # skip comments
          /^[[:space:]]*#/ b

          # add sharp from hold buffer
          H ; s/.*// ; x

          # remove first NL character
          s/\x0A//

      " "$1"
}

# -------------
# get_rms_level
# -------------
#
# $1  filename
#
function get_rms_level()
{
  sox "$1" --null         \
      gain -n -1          \
      contrast 25         \
      stats               \
      2>&1                \
  | sed --quiet           \
        --regexp-extended \
        --expression="

          # add some extra characters for mono files
          s/.+/& @/

          # crop rms level dB
          s/^RMS lev dB[[:space:]]+([^[:space:]]+)[[:space:]].*/\1/p
        "
}

# -----------------
# calculate_n_value
# -----------------
#
# $1  RMS level dB at gain -n -1
#
function calculate_n_value()
{
  bc <<< "-1 - ($1 - -24)"
}

# ------------------------------------------------------------------------------
# commands                                                              commands
# ------------------------------------------------------------------------------

# exactly one argument needed
if (( $# != 1 )) ; then
  echo "$0 <playlist>"
  exit 1
fi

# play each track from given playlist
while true
do

  # get next file from playlist
  MEDIAFILE=$(get_next_line "$1")

  # no more files
  [ -z "$MEDIAFILE" ] && break

  # play single file
  # mplayer "$MEDIAFILE"

  # calculate gain value
  printf "calculating gain value"
  RMS1=$(get_rms_level "$MEDIAFILE")
  GAIN=$(calculate_n_value "$RMS1")
  printf ": %.3f (from rms level %.3f dB)\n" "$GAIN" "$RMS1"

  # play single file at given rms level
  play "$MEDIAFILE"     \
        gain -n "$GAIN" \
        contrast 25

  # wait for second Ctrl+C
  sleep 1

  # comment out last played file
  echo "tagging line as comment..."
  hide_next_line "$1"

done

# signalize success
exit 0

